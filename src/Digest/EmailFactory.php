<?php
namespace Cbcoverseas\Digest;

use ElggSite as Site;
use ElggUser as User;
use Evan\Email\Message;
use Evan\Email\MessageFactory;
use Evan\I18n\Translator;
use Evan\Storage\Db;
use Evan\Time\Clock;
use Evan\Viewer;


/**
 * This class is responsible for generating emails that are then sent to users.
 * 
 * The emails generated by this class contain simple information
 */
class EmailFactory implements MessageFactory {
    
    const LAST_NOTIFIED_METADATA = 'cbc_last_digest_time';

    public function __construct(Clock $clock, Site $site, Viewer $views, Db $db, Translator $i18n) {
        $this->clock = $clock;
        $this->site = $site;
        $this->views = $views;
        $this->db = $db;
        $this->i18n = $i18n;
    }    
    
    /**
     * @param int $limit The maximum number of users to return.
     * 
     * @return User[] A list of users to send the digest to.
     */
    public function getUsers($limit) {
        $users = $this->getNeverNotifiedUsers($limit);
        
	// If we have leftover quota, use it on the least recently notified users.
        $limit -= count($users);
        if ($limit > 0) {
            $users = array_merge($users, $this->getLeastRecentlyNotifiedUsers($limit));
        }
        
        return $users;
    }
    
    /**
     * @param int $limit The maximum number of users to return.
     * 
     * @return User[] A list of users that have never been sent this digest.
     */
    private function getNeverNotifiedUsers($limit) {
        $dbprefix = $this->db->getPrefix();
        $name_metastring_id = $this->db->addMetastring(self::LAST_NOTIFIED_METADATA);

        return $this->db->getEntities(array(
            'type' => 'user',
            'wheres' => array("NOT EXISTS (
                SELECT 1 FROM {$dbprefix}metadata md
                WHERE md.entity_guid = e.guid
                    AND md.name_id = $name_metastring_id)"),
            'limit' => $limit,
        ));
    }
    
    /**
     * @param int $limit The maximum number of users to return.
     * 
     * @return User[] A list of users that have least-recently received the digest.
     */
    private function getLeastRecentlyNotifiedUsers($limit) {
        return $this->db->getEntities(array(
            'type' => 'user',
            'order_by_metadata' => array(
                'name' => self::LAST_NOTIFIED_METADATA,
                'direction' => 'asc',
                'as' => 'integer',
            ),
            'limit' => $limit,
        ));
    }
    
    public function getMostRecentlyNotifiedUsers($limit) {
        return $this->db->getEntities(array(
            'type' => 'user',
            'order_by_metadata' => array(
                'name' => self::LAST_NOTIFIED_METADATA,
                'direction' => 'desc',
                'as' => 'integer',
            ),
            'limit' => $limit,
        ));
    }
     
    private function getSubject(User $user) {
        $date = $this->clock->getDateTime()->format('M j, Y');
        
        return $this->i18n->translate("New activity on %s", array($date), $user->language);
    }
    
    private function getBody(User $user, $activities) {
        $vars = array_merge($activities, array(
            'site' => $this->site,
            'user' => $user,
        ));
        
        // TODO(ewinslow): Make this i18n'able somehow
        return $this->views->view('cbcoverseas/digest.en', $vars, 'email');
    }
    
    private function getActivities(User $user) {
        $results = array();
        
        $last_digest_time = $this->getLastDigestTime($user);
        
        $results['blogs'] = $this->db->getEntities(array(
            'type' => 'object',
            'subtype' => 'blog',
            'created_time_lower' => $last_digest_time,
            'count' => true,
        ));
        
        $results['photos'] = $this->db->getEntities(array(
            'type' => 'object',
            'subtype' => 'image',
            'created_time_lower' => $last_digest_time,
            'count' => true,
        ));
        
        $results['messages'] = $this->db->getEntities(array(
            'type' => 'object',
            'subtype' => 'messages',
            'created_time_lower' => $last_digest_time,
            'metadata_name_value_pairs' => array(
                array('name' => 'toId', 'value' => $user->guid),
                array('name' => 'readYet', 'value' => 0), // only unread messages
            ),
            'count' => true,
        ));
        
        return $results;
    }
    
    private function getLastDigestTime(User $user) {
        // Initialize the last digest time if it hasn't yet been set.
        if (!isset($user->{self::LAST_NOTIFIED_METADATA})) {
            if ($user->last_login) {
                $user->{self::LAST_NOTIFIED_METADATA} = $user->last_login;
            } else {
                $two_weeks_ago = time() - 14 * 24 * 60 * 60;
                $user->{self::LAST_NOTIFIED_METADATA} = $two_weeks_ago;
            }
        }
        
        return $user->{self::LAST_NOTIFIED_METADATA};
    }
    
    /** @override */
    public function createForUser(User $user) {
        $olduser = $this->db->getUser();
        $this->db->setUser($user);
        
        $activities = $this->getActivities($user);
        
        $totalActivities = array_sum(array_values($activities));
	
        // Records the last time we attempted to generate a digest for the user.
        $user->{self::LAST_NOTIFIED_METADATA} = $this->clock->getTimestamp();
        
	// If there's no activity, don't send an email!
        if ($totalActivities <= 0) {
            $this->db->setUser($olduser);
            return NULL;
        }
        
        $message = new Message();
        
        $message->setTo($user->email)
            ->setFrom($this->site->email)
            ->setSubject($this->getSubject($user))
            ->setBody($this->getBody($user, $activities));
        
        $this->db->setUser($olduser);
        
        return $message;
    }
}
